#!/bin/bash

export LANG="C"
export LC_ALL="C"

GEM_RE='([^0-9].*)-([0-9].*)'

readonly currdir="$PWD"
export PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"
declare -A DEV_BRANCHES DEV_REMOTES DEV_REMOTE_BRANCHES
DEV_BRANCHES["master"]="master"
DEV_BRANCHES["openstack-os-build"]="master"
DEV_BRANCHES["hadoop-os-build"]="master"
DEV_REMOTES["origin"]="http://github.com/dellcloudedge/"
DEV_REMOTE_BRANCHES["origin"]="master openstack-os-build hadoop-os-build"

# Source our config file if we have one
[[ -f $HOME/.build-crowbar.conf ]] && \
    . "$HOME/.build-crowbar.conf"

# Look for a local one.
[[ -f build-crowbar.conf ]] && \
    . "build-crowbar.conf"

# Set up our proxies if we were asked to.
if [[ $USE_PROXY = "1" && $PROXY_HOST ]]; then
    proxy_str="http://"
    if [[ $PROXY_PASSWORD && $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER:$PROXY_PASSWORD@"
    elif [[ $PROXY_USER ]]; then
	proxy_str+="$PROXY_USER@"
    fi
    proxy_str+="$PROXY_HOST"
    [[ $PROXY_PORT ]] && proxy_str+=":$PROXY_PORT"
    [[ $no_proxy ]] || no_proxy="localhost,localhost.localdomain,127.0.0.0/8,$PROXY_HOST" 
    [[ $http_proxy ]] || http_proxy="$proxy_str/" 
    [[ $https_proxy ]] || https_proxy="$http_proxy"
    export no_proxy http_proxy https_proxy
else
    unset no_proxy http_proxy https_proxy
fi

# Location of the Crowbar checkout we are building from.
[[ $CROWBAR_DIR ]] || CROWBAR_DIR="${0%/*}"
[[ $CROWBAR_DIR = /* ]] || CROWBAR_DIR="$currdir/$CROWBAR_DIR"
[[ -f $CROWBAR_DIR/build_crowbar.sh && -d $CROWBAR_DIR/.git ]] || \
    die "$CROWBAR_DIR is not a git checkout of Crowbar!" 
export CROWBAR_DIR

. "$CROWBAR_DIR/build_lib.sh" || exit 1
trap - 0 INT QUIT TERM

set -o pipefail

# If we have openstack-os-build and hadoop-os-build brancehs locally,
# let the merge engine know about them.

for branch in openstack-os-build hadoop-os-build; do
    [[ ${DEV_BRANCHES[$branch]} ]] && continue
    in_repo branch_exists "$branch" || continue
done

# Sanity-check our dependency hash

for branch in "${!DEV_BRANCHES[@]}"; do
    in_repo branch_exists "$branch" || \
	die "$branch is specified in \$DEV_BRANCHES, but does not exist!"
    in_repo branch_exists "${DEV_BRANCHES[$branch]}" || \
	die "${DEV_BRANCHES[$branch]} dies not exist, but it is specified as the parent of $branch!"
done

git_is_clean() {
    local line hpath ret=0
    while read line; do
	case $line in
	    # Untracked file.  Ignore it if it is also a git repo, 
	    # complain otherwise.
	    '??'*) hpath=${line%% ->*}
                   hpath=${hpath#* }
		   [[ -d $hpath && -d $hpath.git ]] && continue
                   ret=1;;
	    '') continue;;
	    *) ret=1;
	esac
    done < <(git status --porcelain --ignore-submodules)
    [[ $ret = 0 ]] && return
    git status
    return 1
}

barclamp_is_clean() { in_barclamp "$1" git_is_clean; }

barclamps_are_clean() {
    local bc
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	is_barclamp "${bc##*/}" || continue
	(cd "$bc"; git_is_clean) || return 1
    done
}

crowbar_is_clean() { barclamps_are_clean && in_repo git_is_clean; }

barclamps_in_branch() {
    local b
    for b in "$@"; do
	in_repo branch_exists "$b" || \
	    die "Branch $b does not exist in the Crowbar repo!"
    done
    for b in "$@"; do in_repo git ls-tree -r \
	"refs/remotes/origin/$b" barclamps; done | \
	awk '/160000 commit/ {print $4}' |sort -u
}

fetch_all() {
    local remote barclamps b
    for remote in "${!DEV_REMOTES[@]}"; do
	in_repo git fetch --tags "$remote" || continue
    done
    echo "Fetched updates from ${DEV_REMOTES[$remote]}crowbar.git"
    local barclamps="$(barclamps_in_branch "${!DEV_BRANCHES[@]}")" || \
	exit 1
    for b in $barclamps; do
	[[ -d $CROWBAR_DIR/$b/.git ]] || continue
	(cd "$CROWBAR_DIR/$b"; git fetch --tags) || \
	    die "Cound not fetch updates for $b"
    done
}

curl_and_res() {
    curl "$@"
    case $? in
	0) return 0;;
	7) echo "Unable to contact Github, please try again later." >&2
	    return 1;;
	22) return 1;;
	*) echo "Curl reported error ${?}!." >&2
	    return 1;;
    esac
}

[[ ( $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD) || $1 = setup ]] || \
    die "dev has not been configured. Please run $CROWBAR_DIR/dev setup first."

github_fork() {
    # $1 = user to fork from
    # $2 = repo to fork
    curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" -X POST \
	"https://api.github.com/repos/$1/$2/forks" >&/dev/null || \
	die "Could not fork $1/$2!"
}

setup() {
    local p
    crowbar_is_clean &>/dev/null || \
    	die "Crowbar repo must be clean before trying to set things up!"
    [[ $DEV_GITHUB_ID && $DEV_GITHUB_PASSWD ]] || {
	read -p "Enter your Github username: " DEV_GITHUB_ID
	curl_and_res -f \
	    "https://api.github.com/users/$DEV_GITHUB_ID" &>/dev/null || \
	    die "Could not verify that $DEV_GITHUB_ID is a valid Github user.."
	while [[ $p != $DEV_GITHUB_PASSWD || ! $p ]]; do
	    [[ $p ]] && echo "Passwords did not match, try again."
	    read -s -p "Enter your Github password: " DEV_GITHUB_PASSWD
	    echo
	    read -s -p "Enter your Github password again: " p
	    echo
	done
	curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
	    https://api.github.com/user &>/dev/null || {
	    echo "Unable to authenticate with Github as user $DEV_GITHUB_ID." >&2
	    die "Please try again when you have Github access."
	}
	echo "DEV_GITHUB_ID=\"$DEV_GITHUB_ID\"" >> "$HOME/.build-crowbar.conf"
	echo "DEV_GITHUB_PASSWD=\"$DEV_GITHUB_PASSWD\"" >> "$HOME/.build-crowbar.conf"
    }

    echo "Finding Github repos..."
    local repos=($(
	    eval "$(curl -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
		https://api.github.com/user/repos 2>/dev/null | \
		parse_yml_or_json - name)" 
	    echo "${name[@]}"))
    if ! is_in crowbar "${repos[*]}"; then
	echo "Creating your fork of Crowbar on Github."
	github_fork dellcloudedge crowbar || die "Unable to create your fork of Crowbar."
    fi
    if ! in_repo git config --get remote.personal.url &>/dev/null; then
	echo "Adding remote for personal fork of crowbar on Github."
	in_repo git remote add personal \
	    "http://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/crowbar.git"
	in_repo git fetch personal || \
	    die "Cannot fetch repository info for your Crowbar fork on Github!"
	in_repo git remote set-head -a personal
    fi
    
    for b in ${DEV_REMOTE_BRANCHES["origin"]}; do
	in_repo git checkout "$b" || \
	    die "Cannot checkout $b"
	in_repo git merge "origin/$b" || \
	    die "Cannot merge origin/$b into $b"
	in_repo git submodule update --init || \
	    die "Cannot check out submodules for branch $b"
	in_repo git submodule sync || \
	    die "Cannot sync origin URLs for branch $b"
    done
    in_repo git checkout master
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES["origin"]}); do
	(   cd "$CROWBAR_DIR/$b"
	    repo="$(git config --get remote.origin.url)"
	    [[ $repo =~ /dellcloudedge/ ]] || continue
	    repo="${repo##*/}"
	    repo="${repo%.git}"
	    is_in "$repo" "${repos[*]}" || \
		github_fork dellcloudedge "$repo" || \
		die "Could not create a personal fork of $repo"
	    if ! git config --get remote.personal.url &>/dev/null; then
		git remote add personal \
		    "http://$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD@github.com/$DEV_GITHUB_ID/$repo.git"
		in_repo git fetch personal || \
		    die "Cannot fetch repositroy info for your fork of $repo on Github."
		in_repo git remote set-head -a personal
	    fi
	) || exit 1
    done
}


remote_branches_synced() {
    # $1 = repository to operate in
    # $2 = local branch to test
    # $3 = remote branch to test
    [[ -d $1/.git ]] || \
	die "remote_branches_synced: $1 is not a git repo"
    (cd "$1"; git rev-parse --verify -q "$2" &>/dev/null) || \
	die "remote_branches_synced: $2 does not resolve to a git commit"
    (cd "$1"; git rev-parse --verify -q "$3" &>/dev/null) || \
	die "remote_branches_synced: $3 does not resolve to a git commit"
    # $2 and $3 resolve to the same commit, they are in sync.
    (cd "$1"; [[ $(git rev-parse "$2") = $(git rev-parse "$3") ]] ) && return 0
    # Test to see if there are any commits in $3 that are not
    # reachable from $2.  If there are, then the branches are not synced.
    (cd "$1"; [[ ! $(git rev-list "$2..$3") ]] ) && return 0
    return 1
}

backup_everything() {
    local bc branch
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc && -d $bc/.git ]] || continue
	(   cd "$bc"
	    git config --get remote.personal.url &>/dev/null || continue
	    while read ref branch; do
		branch="${branch#refs/heads/}"
		# If we have a ref for this branch on the personal remote
		# and the local branch does not contain any commits that 
		# the one on the personal remote does, then it is already
		# synced and we can skip the actual network communication.
		git rev-parse --verify -q \
		    refs/remotes/personal/$branch &>/dev/null && \
		    remote_branches_synced "." personal/$branch $branch && \
		    continue
		echo "Pushing $branch to barclamp ${bc##*/} in your Github fork." >&2
		git push -qf personal "$branch:$branch" || \
		die "Could not push $branch to barclamp ${bc##*/} to your Github fork."
		done < <(git show-ref --heads)
	) || exit 1
    done
    if in_repo git config --get remote.personal.url &>/dev/null; then
	# Push branches that have been pushed to personal in the past
	while read ref branch; do
	    branch="${branch#refs/heads/}"
	    # If we do not have a ref for this branch on the personal remote
	    # or on the origin remote, this branch should not be backed up.
	    ( git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null || \
		git rev-parse --verify -q \
		refs/remotes/origin/$branch &>/dev/null) || continue
	    # If this branch has a personal remote and the local branch 
            # does not contain any commits that the one on the personal 
	    # remote does, then it is already synced and we can skip 
	    # the actual network communication.
	    git rev-parse --verify -q \
		refs/remotes/personal/$branch &>/dev/null && \
		remote_branches_synced "." personal/$branch $branch && \
		continue
	    echo "Pushing $branch to your Crowbar fork on Github"
	    in_repo git push -qf personal "$branch:$branch" || \
		die "Could not push $branch to your Crowbar fork on Github"
	done < <(git show-ref --heads)
    fi
}

sync_repo() (
    # $1 = dir to CD to initially.
    # Assumes that origin has already been fetched.
    remote_branches_synced "$1" "master" "origin/master" && return 0
    cd "$1"
    # Repo is not clean, we will refuse to merge in any case.
    git_is_clean || {
	echo "$1 is not clean." >&2
	return 1
    }
    # Grab our current branch to remember it.
    head=$(git symbolic-ref HEAD) || {
	# Oh, boy, we are in detached HEAD.
	# Try some recovery options.
	if [[ $(git rev-list master..HEAD) ]]; then
	    # We have made commits to this detached HEAD.  Just quit
	    echo "$1 has had commits to a detached HEAD."
	    return 1
	else
	    echo "$1: HEAD is detached, and is fast-forwardable to master." >&2
	    echo "git submodule update probably left it in this state" >&2
	    echo "Checking out master..." >&2
	    git checkout master || {
		echo "$bc: unable to check out master, even though it should be clean." >&2
		return 1
	    }
	    head=$(git symbolic-ref HEAD)
	fi
    }
    # If we are not on master, check out master first.
    # We already know that the current branch is clean, so there should be no
    # problem.  Assume that the developer will merge master into this 
    # branch after the fact.
    if [[ $head != refs/heads/master ]]; then
	echo "$1: On branch ${head#refs/heads/} instead of master." >&2
	echo "Will checkout master, merge in upstream changes, and checkout ${head#refs/heads/}." >&2
	echo "master will NOT be merged into ${head#refs/heads/}, you will need to do that manually."
	git checkout master || {
	    echo "$bc: Unable to checkout master!" >&2
	    return 1
	}
    fi
    git merge origin/master || {
	echo "$1: Unable to merge origin/master into master, will unwind." >&2
	git reset --hard
	return 1
    }
    if [[ $head != refs/heads/master ]]; then
	git checkout "${head#refs/heads/}" || {
	    echo "$1: Unable to check out ${head#refs/heads/}"
	    return 1
	}
    fi
)

sync_everything() {
    local unsynced_barclamps=()
    local b u head res=0
    crowbar_is_clean || \
	die "Will not try to sync local repo with origin when working tree is dirty."
    # Do barclamps first.
    for b in $(barclamps_in_branch ${DEV_REMOTE_BRANCHES["origin"]}); do
	sync_repo "$CROWBAR_DIR/$b" && continue
	unsynced_barclamps+=("$b")
    done
    # Finished with barclamps, now for crowbar.
    for b in ${DEV_REMOTE_BRANCHES["origin"]}; do
	# If there are updates from origin, merge them first, followed
	# by updates from our "parent" branch, if any.
	for u in "origin/$b" "${DEV_BRANCHES[$b]}"; do
	    if ! remote_branches_synced "$CROWBAR_DIR" "$b" "$u"
	    then
		if [[ ! $head ]]; then
		    head=$(in_repo git symbolic-ref HEAD) || \
			die "Could not save the current branch!"
		fi
		in_repo git checkout "$b"
		in_repo git merge "$u" || \
		    die "Merge $u into $b branch of Crowbar failed."
	    fi
	done
    done
    [[ $head ]] && in_repo git checkout "${head#refs/heads/}"
    if [[ $unsynced_barclamps ]]; then
	echo "Unable to sync origin with current master in:" >&2
	echo "  ${unsynced_barclamps[*]}"
	res=1
    fi
    [[ $res = 0 ]] && return 0
    echo 
    echo "Please fix things up and rerun sync."
    return 1
}

dev_help () {
    cat <<EOF
$0: Development helper for Crowbar.

Command line options:

  setup -- Sets up your local Crowbar repositories for working with the 
           new Github regime.  This command will prompt for your Github
           login information, make sure you have local copies of all the
           barclamp repos that Crowbar references checked out, create personal
           forks of all the crowbar repos from the dellcloudedge account on
           github, and create the appropriate remotes needed for day-to-day
           operation.

  is_clean -- Check to see if the barclamps have everything committed
              with no untracked files, and check to see if the main
              Crowbar repository is clean while ignoring submodule references.

  fetch -- Fetch all changes from the dellcloudedge Crowbar repositories.
           Does not try to merge any changes into your local repository.
           You can run a fetch at any time without disturbing your working
           code, provided you have network connectivity.

  backup -- Push any locally committed changes in any repositories that were
            initially forked from dellcloudedge into your personal Github forks.
            You can run a backup at any time without disturbing your working
            code, provided you have network connectivity.

  sync -- Merge any changes that have been fetched into the current
          repositories.  dev is_clean should exit without any messages before
          running this command.

  push -- Unconditionally push a branch (or branches) to your crowbar Github
          fork.  Any arguments are interpreted as branch names to push, and
          if there are no arguments it pushes the branch you are currently on.
          Any branches pushed using this command will automatically be backed
          up when dev backup is run as well.

EOF
}

pull_requests_prep() {
    #crowbar_is_clean && fetch_all && sync_everything && backup_everything || \
    #	die "Unable to prepare for pull requests"
    local -A barclamps_to_push
    local -a branches_to_push
    local branch bc
    for branch in ${DEV_REMOTE_BRANCHES["origin"]}; do
	for bc in $(barclamps_in_branch "$branch"); do
	    # If we have already looked at this barclamp, skip it.
	    [[ ${barclamps_to_push["$bc"]} ]] && continue
	    # If there are no commits in master that are not already in 
	    # origin/master, skip it.
	    in_barclamp "${bc##*/}" \
		remote_branches_synced '.' "origin/master" "master" && \
		continue
	    barclamps_to_push["$bc"]="$branch"
	    is_in "$branch" "${branches_to_push[*]}" || \
		branches_to_push+=("$branch")
	done
	remote_branches_synced "$CROWBAR_DIR" "origin/$branch" "$branch" || \
	    is_in "$branch" "${branches_to_push[*]}" || \
	    branches_to_push+=("$branch")
    done
    [[ ${branches_to_push} || ${!barclamps_to_push[*]} ]] || {
	echo "Everything up to date, no pull requests are possible."
	return 0
    }
    echo "Barclamps to update: ${!barclamps_to_push[@]-(none)}"
    echo "Branches to update: ${branches_to_push[@]-(none)}"
    echo "Command to generate pull requests:"
    echo -n "  $0 pull-requests-gen"
    [[ ${branches_to_push} ]] && \
	echo -n " --branches ${branches_to_push[@]}"
    [[ ${!barclamps_to_push[*]} ]] && \
	echo -n " --barclamps ${!barclamps_to_push[@]#barclamps/}"
    echo
}

pull_requests_gen() {
    # $@ = options to parse
    local -A barclamps pull_requests
    local -a branches
    local bc br title body option
    for option in "$@"; do
	case $option in
	    --branches) 
		shift
		while [[ $1 != '--'* ]]; do
		    br="$1"
		    shift
		    in_repo branch_exists "$1" || \
			die "$br is not a branch in Crowbar!"
		    is_in "$1" "${branches[*]}" || branches+="$1"
		done;;
	    --barclamps)
		shift
		while [[ $1 != '--'* ]]; do
		    bc="${1%%/*}"
		    br="${1#*/}"
		    [[ $bc = $br ]] && br="master"
		    shift
		    is_barclamp "$bc" || die "$bc is not a barclamp!"
		    in_barclamp "$bc" branch_exists "$br" || \
			die "$br is not a branch in barclamp $bc!"
		    barclamps["$bc/$br"]="unclassified"
		done;;
	    *) die "Unknown option $1 to $0 pull-requests-gen!";;
	esac
    done
    die "pull-requests-gen: Not implimented yet."
}

push_branches() {
    # $@ = Local branches to push
    local branches=("$@") br
    [[ $branches ]] || br=($(in_repo git symbolic-ref HEAD)) || \
	die "Main Crowbar repo is not on a branch we can push!"
    [[ $br ]] && branches=("${br#refs/heads/}")
    for br in "${branches[@]}"; do
	if in_repo git rev-parse --verify -q "$br" &>/dev/null; then
	    echo "Pushing $br to your Github fork of Crowbar."
	    git push personal "$br:$br"
	else
	    echo "$br is not a branch I can push!"
	fi
    done
}
	    
    
case $1 in
    is_clean) crowbar_is_clean;;
    fetch) fetch_all;;
    sync) sync_everything;;
    setup) setup;;
    backup) backup_everything;;
    push) shift; push_branches "$@";;
    pull-requests-prep) pull_requests_prep;;
    pull-requests-gen) shift; pull_requests_gen "$@";;
    help) dev_help;;
    *) die "Unknown command $1.  Please use \"help\" for help.";;
esac